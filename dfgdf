# Повторный расчет числа итераций k

import math
import numpy as np

# Матрица A (3x3)
A = np.array([[0.0, 0.15625, -0.34375, 0.25],
              [-0.6875, 0.0, 1.75, 0.375],
              [-0.66666, 1.25, 0.0, 0.0],
              [5.33333, 0.5, -0.16666, 0.0]])

# Вектор b (3x1)
b = np.array([-6.71875, 5.1875, -9.6666, 21,16666])

# Начальное приближение x0 (3x1), можно задать как нулевой вектор
x0 = np.array([-6.71875, 5.1875, -9.6666, 21,16666])

alpha_i = np.sum(np.abs(A), axis=1)
alpha = np.max(alpha_i)

# Вычисление бета:
# Сумма модулей элементов по столбцам (бета_i) и поиск максимального бета
beta_i = np.sum(np.abs(A), axis=0)
beta = np.max(beta_i)

# Вычисление гамма:
# Сумма квадратов всех элементов матрицы
gamma = np.sum(A**2)

# Вывод результатов
print("Alpha:", alpha)
print("Beta:", beta)
print("Gamma:", gamma)

# Данные для расчета
# alpha = 0.51786
epsilon = 1e-4
rho_x0_x1 = 0.07632 # тут надо считать вручную, но можешь усовершенствовать)

# Формула для k: k > log((1 - alpha) * epsilon / rho(x0, x1)) / log(alpha)
numerator = math.log(((1 - alpha) * epsilon) / rho_x0_x1)
denominator = math.log(alpha)

# Вычисляем k
k = numerator / denominator
print("Число итераций k:", k)

# Число итераций k
k = 12  # например, 10 итераций

# Итерационный процесс
x = x0
for i in range(k):
    x = np.dot(A, x) + b
    print(f"x^{i+1} = {x}")
